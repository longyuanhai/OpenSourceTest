// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message11.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message11_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message11_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message11_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message11_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message11_2eproto;
class IncomingIndication;
class IncomingIndicationDefaultTypeInternal;
extern IncomingIndicationDefaultTypeInternal _IncomingIndication_default_instance_;
class Indication;
class IndicationDefaultTypeInternal;
extern IndicationDefaultTypeInternal _Indication_default_instance_;
class KeepAliveRequest;
class KeepAliveRequestDefaultTypeInternal;
extern KeepAliveRequestDefaultTypeInternal _KeepAliveRequest_default_instance_;
class KeepAliveResponse;
class KeepAliveResponseDefaultTypeInternal;
extern KeepAliveResponseDefaultTypeInternal _KeepAliveResponse_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class MYMessage;
class MYMessageDefaultTypeInternal;
extern MYMessageDefaultTypeInternal _MYMessage_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::IncomingIndication* Arena::CreateMaybeMessage<::IncomingIndication>(Arena*);
template<> ::Indication* Arena::CreateMaybeMessage<::Indication>(Arena*);
template<> ::KeepAliveRequest* Arena::CreateMaybeMessage<::KeepAliveRequest>(Arena*);
template<> ::KeepAliveResponse* Arena::CreateMaybeMessage<::KeepAliveResponse>(Arena*);
template<> ::LoginRequest* Arena::CreateMaybeMessage<::LoginRequest>(Arena*);
template<> ::LoginResponse* Arena::CreateMaybeMessage<::LoginResponse>(Arena*);
template<> ::MYMessage* Arena::CreateMaybeMessage<::MYMessage>(Arena*);
template<> ::Request* Arena::CreateMaybeMessage<::Request>(Arena*);
template<> ::Response* Arena::CreateMaybeMessage<::Response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MSG : int {
  Login_Request = 0,
  Login_Response = 1,
  KeepAlive_Request = 2,
  KeepAlive_Response = 3,
  Incoming_Indication = 4,
  MSG_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MSG_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MSG_IsValid(int value);
constexpr MSG MSG_MIN = Login_Request;
constexpr MSG MSG_MAX = Incoming_Indication;
constexpr int MSG_ARRAYSIZE = MSG_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MSG_descriptor();
template<typename T>
inline const std::string& MSG_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MSG>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MSG_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MSG_descriptor(), enum_t_value);
}
inline bool MSG_Parse(
    const std::string& name, MSG* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MSG>(
    MSG_descriptor(), name, value);
}
// ===================================================================

class LoginRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const void* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // @@protoc_insertion_point(class_scope:LoginRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(nullptr);
  }

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sessionid = 1;
  void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  const std::string& sessionid() const;
  void set_sessionid(const std::string& value);
  void set_sessionid(std::string&& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  std::string* mutable_sessionid();
  std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);

  // @@protoc_insertion_point(class_scope:LoginResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// -------------------------------------------------------------------

class KeepAliveRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KeepAliveRequest) */ {
 public:
  KeepAliveRequest();
  virtual ~KeepAliveRequest();

  KeepAliveRequest(const KeepAliveRequest& from);
  KeepAliveRequest(KeepAliveRequest&& from) noexcept
    : KeepAliveRequest() {
    *this = ::std::move(from);
  }

  inline KeepAliveRequest& operator=(const KeepAliveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepAliveRequest& operator=(KeepAliveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeepAliveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeepAliveRequest* internal_default_instance() {
    return reinterpret_cast<const KeepAliveRequest*>(
               &_KeepAliveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(KeepAliveRequest* other);
  friend void swap(KeepAliveRequest& a, KeepAliveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeepAliveRequest* New() const final {
    return CreateMaybeMessage<KeepAliveRequest>(nullptr);
  }

  KeepAliveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeepAliveRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeepAliveRequest& from);
  void MergeFrom(const KeepAliveRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeepAliveRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KeepAliveRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sessionid = 1;
  void clear_sessionid();
  static const int kSessionidFieldNumber = 1;
  const std::string& sessionid() const;
  void set_sessionid(const std::string& value);
  void set_sessionid(std::string&& value);
  void set_sessionid(const char* value);
  void set_sessionid(const char* value, size_t size);
  std::string* mutable_sessionid();
  std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);

  // @@protoc_insertion_point(class_scope:KeepAliveRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// -------------------------------------------------------------------

class KeepAliveResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KeepAliveResponse) */ {
 public:
  KeepAliveResponse();
  virtual ~KeepAliveResponse();

  KeepAliveResponse(const KeepAliveResponse& from);
  KeepAliveResponse(KeepAliveResponse&& from) noexcept
    : KeepAliveResponse() {
    *this = ::std::move(from);
  }

  inline KeepAliveResponse& operator=(const KeepAliveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepAliveResponse& operator=(KeepAliveResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeepAliveResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeepAliveResponse* internal_default_instance() {
    return reinterpret_cast<const KeepAliveResponse*>(
               &_KeepAliveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(KeepAliveResponse* other);
  friend void swap(KeepAliveResponse& a, KeepAliveResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeepAliveResponse* New() const final {
    return CreateMaybeMessage<KeepAliveResponse>(nullptr);
  }

  KeepAliveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeepAliveResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeepAliveResponse& from);
  void MergeFrom(const KeepAliveResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeepAliveResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KeepAliveResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cainiao = 1;
  void clear_cainiao();
  static const int kCainiaoFieldNumber = 1;
  const std::string& cainiao() const;
  void set_cainiao(const std::string& value);
  void set_cainiao(std::string&& value);
  void set_cainiao(const char* value);
  void set_cainiao(const char* value, size_t size);
  std::string* mutable_cainiao();
  std::string* release_cainiao();
  void set_allocated_cainiao(std::string* cainiao);

  // @@protoc_insertion_point(class_scope:KeepAliveResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cainiao_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// -------------------------------------------------------------------

class IncomingIndication :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IncomingIndication) */ {
 public:
  IncomingIndication();
  virtual ~IncomingIndication();

  IncomingIndication(const IncomingIndication& from);
  IncomingIndication(IncomingIndication&& from) noexcept
    : IncomingIndication() {
    *this = ::std::move(from);
  }

  inline IncomingIndication& operator=(const IncomingIndication& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncomingIndication& operator=(IncomingIndication&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IncomingIndication& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IncomingIndication* internal_default_instance() {
    return reinterpret_cast<const IncomingIndication*>(
               &_IncomingIndication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(IncomingIndication* other);
  friend void swap(IncomingIndication& a, IncomingIndication& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IncomingIndication* New() const final {
    return CreateMaybeMessage<IncomingIndication>(nullptr);
  }

  IncomingIndication* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IncomingIndication>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IncomingIndication& from);
  void MergeFrom(const IncomingIndication& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncomingIndication* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IncomingIndication";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const void* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // @@protoc_insertion_point(class_scope:IncomingIndication)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// -------------------------------------------------------------------

class Request :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Request";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .LoginRequest loginRequest = 1;
  bool has_loginrequest() const;
  void clear_loginrequest();
  static const int kLoginRequestFieldNumber = 1;
  const ::LoginRequest& loginrequest() const;
  ::LoginRequest* release_loginrequest();
  ::LoginRequest* mutable_loginrequest();
  void set_allocated_loginrequest(::LoginRequest* loginrequest);

  // .KeepAliveRequest keepAliveRequest = 2;
  bool has_keepaliverequest() const;
  void clear_keepaliverequest();
  static const int kKeepAliveRequestFieldNumber = 2;
  const ::KeepAliveRequest& keepaliverequest() const;
  ::KeepAliveRequest* release_keepaliverequest();
  ::KeepAliveRequest* mutable_keepaliverequest();
  void set_allocated_keepaliverequest(::KeepAliveRequest* keepaliverequest);

  // @@protoc_insertion_point(class_scope:Request)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::LoginRequest* loginrequest_;
  ::KeepAliveRequest* keepaliverequest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// -------------------------------------------------------------------

class Response :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Response";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes err_description = 2;
  void clear_err_description();
  static const int kErrDescriptionFieldNumber = 2;
  const std::string& err_description() const;
  void set_err_description(const std::string& value);
  void set_err_description(std::string&& value);
  void set_err_description(const char* value);
  void set_err_description(const void* value, size_t size);
  std::string* mutable_err_description();
  std::string* release_err_description();
  void set_allocated_err_description(std::string* err_description);

  // .LoginResponse loginResponse = 3;
  bool has_loginresponse() const;
  void clear_loginresponse();
  static const int kLoginResponseFieldNumber = 3;
  const ::LoginResponse& loginresponse() const;
  ::LoginResponse* release_loginresponse();
  ::LoginResponse* mutable_loginresponse();
  void set_allocated_loginresponse(::LoginResponse* loginresponse);

  // .KeepAliveResponse keepAliveResponse = 4;
  bool has_keepaliveresponse() const;
  void clear_keepaliveresponse();
  static const int kKeepAliveResponseFieldNumber = 4;
  const ::KeepAliveResponse& keepaliveresponse() const;
  ::KeepAliveResponse* release_keepaliveresponse();
  ::KeepAliveResponse* mutable_keepaliveresponse();
  void set_allocated_keepaliveresponse(::KeepAliveResponse* keepaliveresponse);

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:Response)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_description_;
  ::LoginResponse* loginresponse_;
  ::KeepAliveResponse* keepaliveresponse_;
  bool result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// -------------------------------------------------------------------

class Indication :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Indication) */ {
 public:
  Indication();
  virtual ~Indication();

  Indication(const Indication& from);
  Indication(Indication&& from) noexcept
    : Indication() {
    *this = ::std::move(from);
  }

  inline Indication& operator=(const Indication& from) {
    CopyFrom(from);
    return *this;
  }
  inline Indication& operator=(Indication&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Indication& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Indication* internal_default_instance() {
    return reinterpret_cast<const Indication*>(
               &_Indication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Indication* other);
  friend void swap(Indication& a, Indication& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Indication* New() const final {
    return CreateMaybeMessage<Indication>(nullptr);
  }

  Indication* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Indication>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Indication& from);
  void MergeFrom(const Indication& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Indication* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Indication";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .IncomingIndication incomingIndication = 1;
  bool has_incomingindication() const;
  void clear_incomingindication();
  static const int kIncomingIndicationFieldNumber = 1;
  const ::IncomingIndication& incomingindication() const;
  ::IncomingIndication* release_incomingindication();
  ::IncomingIndication* mutable_incomingindication();
  void set_allocated_incomingindication(::IncomingIndication* incomingindication);

  // @@protoc_insertion_point(class_scope:Indication)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::IncomingIndication* incomingindication_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// -------------------------------------------------------------------

class MYMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MYMessage) */ {
 public:
  MYMessage();
  virtual ~MYMessage();

  MYMessage(const MYMessage& from);
  MYMessage(MYMessage&& from) noexcept
    : MYMessage() {
    *this = ::std::move(from);
  }

  inline MYMessage& operator=(const MYMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MYMessage& operator=(MYMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MYMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MYMessage* internal_default_instance() {
    return reinterpret_cast<const MYMessage*>(
               &_MYMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MYMessage* other);
  friend void swap(MYMessage& a, MYMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MYMessage* New() const final {
    return CreateMaybeMessage<MYMessage>(nullptr);
  }

  MYMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MYMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MYMessage& from);
  void MergeFrom(const MYMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MYMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MYMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message11_2eproto);
    return ::descriptor_table_message11_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Request request = 3;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 3;
  const ::Request& request() const;
  ::Request* release_request();
  ::Request* mutable_request();
  void set_allocated_request(::Request* request);

  // .Response response = 4;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 4;
  const ::Response& response() const;
  ::Response* release_response();
  ::Response* mutable_response();
  void set_allocated_response(::Response* response);

  // .Indication indication = 5;
  bool has_indication() const;
  void clear_indication();
  static const int kIndicationFieldNumber = 5;
  const ::Indication& indication() const;
  ::Indication* release_indication();
  ::Indication* mutable_indication();
  void set_allocated_indication(::Indication* indication);

  // .MSG type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::MSG type() const;
  void set_type(::MSG value);

  // fixed32 sequence = 2;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence() const;
  void set_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:MYMessage)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Request* request_;
  ::Response* response_;
  ::Indication* indication_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message11_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// bytes username = 1;
inline void LoginRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:LoginRequest.username)
  return username_.GetNoArena();
}
inline void LoginRequest::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.username)
}
inline void LoginRequest::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.username)
}
inline void LoginRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.username)
}
inline void LoginRequest::set_username(const void* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:LoginRequest.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.username)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:LoginRequest.password)
  return password_.GetNoArena();
}
inline void LoginRequest::set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginRequest.password)
}
inline void LoginRequest::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:LoginRequest.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:LoginRequest.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginResponse

// string sessionid = 1;
inline void LoginResponse::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:LoginResponse.sessionid)
  return sessionid_.GetNoArena();
}
inline void LoginResponse::set_sessionid(const std::string& value) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LoginResponse.sessionid)
}
inline void LoginResponse::set_sessionid(std::string&& value) {
  
  sessionid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginResponse.sessionid)
}
inline void LoginResponse::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginResponse.sessionid)
}
inline void LoginResponse::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginResponse.sessionid)
}
inline std::string* LoginResponse::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:LoginResponse.sessionid)
  return sessionid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginResponse::release_sessionid() {
  // @@protoc_insertion_point(field_release:LoginResponse.sessionid)
  
  return sessionid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:LoginResponse.sessionid)
}

// -------------------------------------------------------------------

// KeepAliveRequest

// string sessionid = 1;
inline void KeepAliveRequest::clear_sessionid() {
  sessionid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KeepAliveRequest::sessionid() const {
  // @@protoc_insertion_point(field_get:KeepAliveRequest.sessionid)
  return sessionid_.GetNoArena();
}
inline void KeepAliveRequest::set_sessionid(const std::string& value) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeepAliveRequest.sessionid)
}
inline void KeepAliveRequest::set_sessionid(std::string&& value) {
  
  sessionid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeepAliveRequest.sessionid)
}
inline void KeepAliveRequest::set_sessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeepAliveRequest.sessionid)
}
inline void KeepAliveRequest::set_sessionid(const char* value, size_t size) {
  
  sessionid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeepAliveRequest.sessionid)
}
inline std::string* KeepAliveRequest::mutable_sessionid() {
  
  // @@protoc_insertion_point(field_mutable:KeepAliveRequest.sessionid)
  return sessionid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KeepAliveRequest::release_sessionid() {
  // @@protoc_insertion_point(field_release:KeepAliveRequest.sessionid)
  
  return sessionid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KeepAliveRequest::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid);
  // @@protoc_insertion_point(field_set_allocated:KeepAliveRequest.sessionid)
}

// -------------------------------------------------------------------

// KeepAliveResponse

// string cainiao = 1;
inline void KeepAliveResponse::clear_cainiao() {
  cainiao_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KeepAliveResponse::cainiao() const {
  // @@protoc_insertion_point(field_get:KeepAliveResponse.cainiao)
  return cainiao_.GetNoArena();
}
inline void KeepAliveResponse::set_cainiao(const std::string& value) {
  
  cainiao_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeepAliveResponse.cainiao)
}
inline void KeepAliveResponse::set_cainiao(std::string&& value) {
  
  cainiao_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeepAliveResponse.cainiao)
}
inline void KeepAliveResponse::set_cainiao(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cainiao_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeepAliveResponse.cainiao)
}
inline void KeepAliveResponse::set_cainiao(const char* value, size_t size) {
  
  cainiao_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeepAliveResponse.cainiao)
}
inline std::string* KeepAliveResponse::mutable_cainiao() {
  
  // @@protoc_insertion_point(field_mutable:KeepAliveResponse.cainiao)
  return cainiao_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KeepAliveResponse::release_cainiao() {
  // @@protoc_insertion_point(field_release:KeepAliveResponse.cainiao)
  
  return cainiao_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KeepAliveResponse::set_allocated_cainiao(std::string* cainiao) {
  if (cainiao != nullptr) {
    
  } else {
    
  }
  cainiao_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cainiao);
  // @@protoc_insertion_point(field_set_allocated:KeepAliveResponse.cainiao)
}

// -------------------------------------------------------------------

// IncomingIndication

// bytes username = 1;
inline void IncomingIndication::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& IncomingIndication::username() const {
  // @@protoc_insertion_point(field_get:IncomingIndication.username)
  return username_.GetNoArena();
}
inline void IncomingIndication::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IncomingIndication.username)
}
inline void IncomingIndication::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IncomingIndication.username)
}
inline void IncomingIndication::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IncomingIndication.username)
}
inline void IncomingIndication::set_username(const void* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IncomingIndication.username)
}
inline std::string* IncomingIndication::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:IncomingIndication.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* IncomingIndication::release_username() {
  // @@protoc_insertion_point(field_release:IncomingIndication.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void IncomingIndication::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:IncomingIndication.username)
}

// -------------------------------------------------------------------

// Request

// .LoginRequest loginRequest = 1;
inline bool Request::has_loginrequest() const {
  return this != internal_default_instance() && loginrequest_ != nullptr;
}
inline void Request::clear_loginrequest() {
  if (GetArenaNoVirtual() == nullptr && loginrequest_ != nullptr) {
    delete loginrequest_;
  }
  loginrequest_ = nullptr;
}
inline const ::LoginRequest& Request::loginrequest() const {
  const ::LoginRequest* p = loginrequest_;
  // @@protoc_insertion_point(field_get:Request.loginRequest)
  return p != nullptr ? *p : *reinterpret_cast<const ::LoginRequest*>(
      &::_LoginRequest_default_instance_);
}
inline ::LoginRequest* Request::release_loginrequest() {
  // @@protoc_insertion_point(field_release:Request.loginRequest)
  
  ::LoginRequest* temp = loginrequest_;
  loginrequest_ = nullptr;
  return temp;
}
inline ::LoginRequest* Request::mutable_loginrequest() {
  
  if (loginrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::LoginRequest>(GetArenaNoVirtual());
    loginrequest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Request.loginRequest)
  return loginrequest_;
}
inline void Request::set_allocated_loginrequest(::LoginRequest* loginrequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete loginrequest_;
  }
  if (loginrequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      loginrequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loginrequest, submessage_arena);
    }
    
  } else {
    
  }
  loginrequest_ = loginrequest;
  // @@protoc_insertion_point(field_set_allocated:Request.loginRequest)
}

// .KeepAliveRequest keepAliveRequest = 2;
inline bool Request::has_keepaliverequest() const {
  return this != internal_default_instance() && keepaliverequest_ != nullptr;
}
inline void Request::clear_keepaliverequest() {
  if (GetArenaNoVirtual() == nullptr && keepaliverequest_ != nullptr) {
    delete keepaliverequest_;
  }
  keepaliverequest_ = nullptr;
}
inline const ::KeepAliveRequest& Request::keepaliverequest() const {
  const ::KeepAliveRequest* p = keepaliverequest_;
  // @@protoc_insertion_point(field_get:Request.keepAliveRequest)
  return p != nullptr ? *p : *reinterpret_cast<const ::KeepAliveRequest*>(
      &::_KeepAliveRequest_default_instance_);
}
inline ::KeepAliveRequest* Request::release_keepaliverequest() {
  // @@protoc_insertion_point(field_release:Request.keepAliveRequest)
  
  ::KeepAliveRequest* temp = keepaliverequest_;
  keepaliverequest_ = nullptr;
  return temp;
}
inline ::KeepAliveRequest* Request::mutable_keepaliverequest() {
  
  if (keepaliverequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::KeepAliveRequest>(GetArenaNoVirtual());
    keepaliverequest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Request.keepAliveRequest)
  return keepaliverequest_;
}
inline void Request::set_allocated_keepaliverequest(::KeepAliveRequest* keepaliverequest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete keepaliverequest_;
  }
  if (keepaliverequest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      keepaliverequest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keepaliverequest, submessage_arena);
    }
    
  } else {
    
  }
  keepaliverequest_ = keepaliverequest;
  // @@protoc_insertion_point(field_set_allocated:Request.keepAliveRequest)
}

// -------------------------------------------------------------------

// Response

// bool result = 1;
inline void Response::clear_result() {
  result_ = false;
}
inline bool Response::result() const {
  // @@protoc_insertion_point(field_get:Response.result)
  return result_;
}
inline void Response::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:Response.result)
}

// bytes err_description = 2;
inline void Response::clear_err_description() {
  err_description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Response::err_description() const {
  // @@protoc_insertion_point(field_get:Response.err_description)
  return err_description_.GetNoArena();
}
inline void Response::set_err_description(const std::string& value) {
  
  err_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Response.err_description)
}
inline void Response::set_err_description(std::string&& value) {
  
  err_description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Response.err_description)
}
inline void Response::set_err_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  err_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Response.err_description)
}
inline void Response::set_err_description(const void* value, size_t size) {
  
  err_description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Response.err_description)
}
inline std::string* Response::mutable_err_description() {
  
  // @@protoc_insertion_point(field_mutable:Response.err_description)
  return err_description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Response::release_err_description() {
  // @@protoc_insertion_point(field_release:Response.err_description)
  
  return err_description_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_err_description(std::string* err_description) {
  if (err_description != nullptr) {
    
  } else {
    
  }
  err_description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_description);
  // @@protoc_insertion_point(field_set_allocated:Response.err_description)
}

// .LoginResponse loginResponse = 3;
inline bool Response::has_loginresponse() const {
  return this != internal_default_instance() && loginresponse_ != nullptr;
}
inline void Response::clear_loginresponse() {
  if (GetArenaNoVirtual() == nullptr && loginresponse_ != nullptr) {
    delete loginresponse_;
  }
  loginresponse_ = nullptr;
}
inline const ::LoginResponse& Response::loginresponse() const {
  const ::LoginResponse* p = loginresponse_;
  // @@protoc_insertion_point(field_get:Response.loginResponse)
  return p != nullptr ? *p : *reinterpret_cast<const ::LoginResponse*>(
      &::_LoginResponse_default_instance_);
}
inline ::LoginResponse* Response::release_loginresponse() {
  // @@protoc_insertion_point(field_release:Response.loginResponse)
  
  ::LoginResponse* temp = loginresponse_;
  loginresponse_ = nullptr;
  return temp;
}
inline ::LoginResponse* Response::mutable_loginresponse() {
  
  if (loginresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::LoginResponse>(GetArenaNoVirtual());
    loginresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Response.loginResponse)
  return loginresponse_;
}
inline void Response::set_allocated_loginresponse(::LoginResponse* loginresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete loginresponse_;
  }
  if (loginresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      loginresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loginresponse, submessage_arena);
    }
    
  } else {
    
  }
  loginresponse_ = loginresponse;
  // @@protoc_insertion_point(field_set_allocated:Response.loginResponse)
}

// .KeepAliveResponse keepAliveResponse = 4;
inline bool Response::has_keepaliveresponse() const {
  return this != internal_default_instance() && keepaliveresponse_ != nullptr;
}
inline void Response::clear_keepaliveresponse() {
  if (GetArenaNoVirtual() == nullptr && keepaliveresponse_ != nullptr) {
    delete keepaliveresponse_;
  }
  keepaliveresponse_ = nullptr;
}
inline const ::KeepAliveResponse& Response::keepaliveresponse() const {
  const ::KeepAliveResponse* p = keepaliveresponse_;
  // @@protoc_insertion_point(field_get:Response.keepAliveResponse)
  return p != nullptr ? *p : *reinterpret_cast<const ::KeepAliveResponse*>(
      &::_KeepAliveResponse_default_instance_);
}
inline ::KeepAliveResponse* Response::release_keepaliveresponse() {
  // @@protoc_insertion_point(field_release:Response.keepAliveResponse)
  
  ::KeepAliveResponse* temp = keepaliveresponse_;
  keepaliveresponse_ = nullptr;
  return temp;
}
inline ::KeepAliveResponse* Response::mutable_keepaliveresponse() {
  
  if (keepaliveresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::KeepAliveResponse>(GetArenaNoVirtual());
    keepaliveresponse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Response.keepAliveResponse)
  return keepaliveresponse_;
}
inline void Response::set_allocated_keepaliveresponse(::KeepAliveResponse* keepaliveresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete keepaliveresponse_;
  }
  if (keepaliveresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      keepaliveresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keepaliveresponse, submessage_arena);
    }
    
  } else {
    
  }
  keepaliveresponse_ = keepaliveresponse;
  // @@protoc_insertion_point(field_set_allocated:Response.keepAliveResponse)
}

// -------------------------------------------------------------------

// Indication

// .IncomingIndication incomingIndication = 1;
inline bool Indication::has_incomingindication() const {
  return this != internal_default_instance() && incomingindication_ != nullptr;
}
inline void Indication::clear_incomingindication() {
  if (GetArenaNoVirtual() == nullptr && incomingindication_ != nullptr) {
    delete incomingindication_;
  }
  incomingindication_ = nullptr;
}
inline const ::IncomingIndication& Indication::incomingindication() const {
  const ::IncomingIndication* p = incomingindication_;
  // @@protoc_insertion_point(field_get:Indication.incomingIndication)
  return p != nullptr ? *p : *reinterpret_cast<const ::IncomingIndication*>(
      &::_IncomingIndication_default_instance_);
}
inline ::IncomingIndication* Indication::release_incomingindication() {
  // @@protoc_insertion_point(field_release:Indication.incomingIndication)
  
  ::IncomingIndication* temp = incomingindication_;
  incomingindication_ = nullptr;
  return temp;
}
inline ::IncomingIndication* Indication::mutable_incomingindication() {
  
  if (incomingindication_ == nullptr) {
    auto* p = CreateMaybeMessage<::IncomingIndication>(GetArenaNoVirtual());
    incomingindication_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Indication.incomingIndication)
  return incomingindication_;
}
inline void Indication::set_allocated_incomingindication(::IncomingIndication* incomingindication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete incomingindication_;
  }
  if (incomingindication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      incomingindication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, incomingindication, submessage_arena);
    }
    
  } else {
    
  }
  incomingindication_ = incomingindication;
  // @@protoc_insertion_point(field_set_allocated:Indication.incomingIndication)
}

// -------------------------------------------------------------------

// MYMessage

// .MSG type = 1;
inline void MYMessage::clear_type() {
  type_ = 0;
}
inline ::MSG MYMessage::type() const {
  // @@protoc_insertion_point(field_get:MYMessage.type)
  return static_cast< ::MSG >(type_);
}
inline void MYMessage::set_type(::MSG value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:MYMessage.type)
}

// fixed32 sequence = 2;
inline void MYMessage::clear_sequence() {
  sequence_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MYMessage::sequence() const {
  // @@protoc_insertion_point(field_get:MYMessage.sequence)
  return sequence_;
}
inline void MYMessage::set_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:MYMessage.sequence)
}

// .Request request = 3;
inline bool MYMessage::has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline void MYMessage::clear_request() {
  if (GetArenaNoVirtual() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::Request& MYMessage::request() const {
  const ::Request* p = request_;
  // @@protoc_insertion_point(field_get:MYMessage.request)
  return p != nullptr ? *p : *reinterpret_cast<const ::Request*>(
      &::_Request_default_instance_);
}
inline ::Request* MYMessage::release_request() {
  // @@protoc_insertion_point(field_release:MYMessage.request)
  
  ::Request* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::Request* MYMessage::mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::Request>(GetArenaNoVirtual());
    request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MYMessage.request)
  return request_;
}
inline void MYMessage::set_allocated_request(::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:MYMessage.request)
}

// .Response response = 4;
inline bool MYMessage::has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline void MYMessage::clear_response() {
  if (GetArenaNoVirtual() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::Response& MYMessage::response() const {
  const ::Response* p = response_;
  // @@protoc_insertion_point(field_get:MYMessage.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::Response*>(
      &::_Response_default_instance_);
}
inline ::Response* MYMessage::release_response() {
  // @@protoc_insertion_point(field_release:MYMessage.response)
  
  ::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::Response* MYMessage::mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Response>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MYMessage.response)
  return response_;
}
inline void MYMessage::set_allocated_response(::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:MYMessage.response)
}

// .Indication indication = 5;
inline bool MYMessage::has_indication() const {
  return this != internal_default_instance() && indication_ != nullptr;
}
inline void MYMessage::clear_indication() {
  if (GetArenaNoVirtual() == nullptr && indication_ != nullptr) {
    delete indication_;
  }
  indication_ = nullptr;
}
inline const ::Indication& MYMessage::indication() const {
  const ::Indication* p = indication_;
  // @@protoc_insertion_point(field_get:MYMessage.indication)
  return p != nullptr ? *p : *reinterpret_cast<const ::Indication*>(
      &::_Indication_default_instance_);
}
inline ::Indication* MYMessage::release_indication() {
  // @@protoc_insertion_point(field_release:MYMessage.indication)
  
  ::Indication* temp = indication_;
  indication_ = nullptr;
  return temp;
}
inline ::Indication* MYMessage::mutable_indication() {
  
  if (indication_ == nullptr) {
    auto* p = CreateMaybeMessage<::Indication>(GetArenaNoVirtual());
    indication_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MYMessage.indication)
  return indication_;
}
inline void MYMessage::set_allocated_indication(::Indication* indication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete indication_;
  }
  if (indication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      indication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, indication, submessage_arena);
    }
    
  } else {
    
  }
  indication_ = indication;
  // @@protoc_insertion_point(field_set_allocated:MYMessage.indication)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MSG> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MSG>() {
  return ::MSG_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message11_2eproto
